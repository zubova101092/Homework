#1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
#Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
#Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#31    32         3    5    32        3    5    8    3
#37    43         2    4    6         8    3    7    1
#51    86        -1   64   -8
#Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно —
# первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
class Matrix:
    def __init__(self, ar_of_ar):
        len_of_matrix = len(ar_of_ar[0])
        for ar in ar_of_ar:
            if not len(ar) == len_of_matrix:
                print(f'Передан массив массивов разных длинн.')
                raise ValueError
        self._data = ar_of_ar

    def __str__(self):
        result = f'Matrix\n(\t' + f'\t)\n(\t'.join(f', '.join(str(x) for x in line) for line in self._data) + f'\t);'
        return result

    def __add__(self, other):
        len_of_matrix = len(self._data[0])
        hig_of_matrix = len(self._data)
        if not (len_of_matrix == len(other._data[0]) and hig_of_matrix == len(other._data)):
            print("К сложению принимаются матрицы одинаковых размеров.")
            raise ValueError
        result = [[self._data[y][x] + other._data[y][x] for x in range(len_of_matrix)]
                  for y in range(hig_of_matrix)]
        return Matrix(result)


if __name__ == '__main__':
    m = Matrix([[], [], []])
    m2 = Matrix([[1, 2], [3, 4], [5, 6]])
    m_2 = Matrix([[-6, -5], [4, 3], [-2, -1]])

    print(m)
    print(m2)

    m3 = m2 + m_2
    print(m3)

#2. Реализовать проект расчёта суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название.
# К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3).
# Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта,
# проверить на практике работу декоратора @property.
from abc import abstractmethod


class Clothes:

    def __init__(self, size=0):
        self.size = size

    @abstractmethod
    def cloth_out(self):
        pass


class Coat(Clothes):

    def __init__(self, size):
        super(Coat, self).__init__(size)

    def cloth_out(self):
        return self.size / 6.5 + 0.5


class Suit(Clothes):

    def __init__(self, size):
        super(Suit, self).__init__(size)

    def cloth_out(self):
        return self.size * 2 + 0.3

    @staticmethod
    def __define_size_by_value(val):
        return (val - 0.3) // 2

    @property
    def size_out(self):
        return self.size

    @size_out.setter
    def size_out(self, val):
        tmp_size = int(self.__define_size_by_value(val))
        print(f'Этого хватает на {tmp_size}-й размер.')
        if tmp_size < 1:
            print('Невозможно использовать это количество ткани.')
        else:
            print('Применяем.')
            self.size = tmp_size


if __name__ == '__main__':
    c = Coat(12)
    print(c.cloth_out())

    s = Suit(12)
    print(s.cloth_out())
    print(s.size_out)
    s.size_out = 36
    print(s.cloth_out())

#3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого)
# деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля,
# иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
#Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.
class Egg:

    def __init__(self, cells):
        self.cells = cells

    def __add__(self, other):
        return Egg(self.cells + other.cells)

    def __sub__(self, other):
        if self.cells <= other.cells:
            print('Вычитание невозможно, так как уходим в минус')
            raise ValueError
        return Egg(self.cells - other.cells)

    def __mul__(self, other):
        return Egg(self.cells * other.cells)

    def __truediv__(self, other):
        return Egg(round(self.cells / other.cells))

    def make_order(self, row):
        ordered = ['*' * row for _ in range(self.cells // row)]
        ordered.append('*' * (self.cells % row))
        return f'\n'.join(ordered)


if __name__ == '__main__':
    e1 = Egg(20)
    e2 = Egg(30)
    e3 = e1 + e2
    try:
        e4 = e3 - Egg(100)
    except ValueError as e:
        e4 = e3 - Egg(10)
    finally:
        print(f'e4.cells={e4.cells}')
    e5 = e3 * e4
    e6 = e5 / e1
    print(f'e1:7: cells({e1.cells})\n{e1.make_order(7)}')
    print(f'e2:7: cells({e2.cells})\n{e2.make_order(7)}')
    print(f'e3:7: cells({e3.cells})\n{e3.make_order(7)}')
    print(f'e4:7: cells({e4.cells})\n{e4.make_order(7)}')
    print(f'e5:70: cells({e5.cells})\n{e5.make_order(70)}')
    print(f'e6:7: cells({e6.cells})\n{e6.make_order(7)}')
